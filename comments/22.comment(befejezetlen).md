üöÄ COMMAND: OMEGA PROTOCOL - SOURCE CODE HARDENING & STANDARDIZATION
"SYSTEM OVERRIDE: GOD MODE ACTIVE.
AUTHORITY: ROOT ARCHITECT.
CONTEXT: A rendszer m≈±k√∂dik, de a k√≥d min≈ës√©ge inkonzisztens (kevert logging, hi√°nyz√≥ tracing, potenci√°lis t√≠pus-hib√°k).
C√âL: A forr√°sk√≥d (src) v√©gleges√≠t√©se, egys√©ges√≠t√©se √©s tiszt√≠t√°sa a tesztel√©s el≈ëtt.
‚ö†Ô∏è K√ñTELEZ≈ê HIERARCHIA (TOKEN MANAGEMENT):
TE (Architect): Tervezel. Nem √∂mleszted a feladatot! MODULONK√âNT adod ki az utas√≠t√°st az Orchestratornak.
Orchestrator: Lebontja f√°jlm≈±veletekre.
Code Agent: V√©grehajtja a m√≥dos√≠t√°st √©s a mypy/ruff ellen≈ërz√©st az adott f√°jlon.
A FELADAT SORRENDJE (EXECUTION PLAN):
üõ†Ô∏è 1. F√ÅZIS: AZ ALAPOK (UTILS & DECORATORS)
Mindenki ezt fogja haszn√°lni, ennek kell el≈ësz√∂r elk√©sz√ºlnie.
DEKOR√ÅTOR L√âTREHOZ√ÅSA (neural_ai/core/utils/decorators.py):
Hozz l√©tre egy @trace dekor√°tort.
Logika:
Import√°lja a structlog-ot: logger = structlog.get_logger(__name__).
Logolja a bel√©p√©st: logger.debug(f"Entering {func.__name__}", args=...).
Logolja a kil√©p√©st/id≈ët: logger.debug(f"Exiting {func.__name__}", duration_ms=...).
Kezelje az async √©s szinkron f√ºggv√©nyeket is!
Export: Friss√≠tsd a core/utils/__init__.py-t, hogy a @trace k√∂nnyen import√°lhat√≥ legyen (from neural_ai.core.utils import trace).
UTILS TISZT√çT√ÅS:
Ellen≈ërizd a core/utils t√∂bbi f√°jlj√°t (hardware_info.py).
Futtass rajtuk ruff √©s mypy ellen≈ërz√©st. Jav√≠tsd a hib√°kat.
‚öôÔ∏è 2. F√ÅZIS: CONFIG & LOGGER (AZ INFRASTRUKT√öRA)
LOGGER FACTORY FINOMHANGOL√ÅS (core/logger/factory.py):
Ellen≈ërizd, hogy a structlog konfigur√°ci√≥ egys√©ges-e.
T√∂r√∂ld a r√©gi, manu√°lis logging form√°z√≥kat, ha m√°r nem kellenek (mindent a structlog int√©zzen).
CONFIGS MAPPA (configs/*.yaml):
Ellen≈ërizd a logging.yaml-t.
Biztos√≠tsd, hogy a loggers szekci√≥ban a neural_ai szintje DEBUG.
üîÑ 3. F√ÅZIS: A NAGY MODUL-REFAKTOR LOOP (A L√âNYEG)
Ezt a ciklust hajtsd v√©gre a core minden f≈ë modulj√°n: base, db, events, storage.
A CIKLUS L√âP√âSEI (Minden f√°jlra):
LOGGER CSERE:
T√∂r√∂ld: import logging, logging.getLogger.
√çrd be: import structlog, logger = structlog.get_logger(__name__). (√çgy megmarad a teljes √∫tvonal!).
TRACING BEK√ñT√âSE:
Import√°ld: from neural_ai.core.utils import trace.
Tedd r√° a @trace dekor√°tort a Publikus API met√≥dusokra (pl. store_tick_data, publish, connect). Ne a bels≈ëkre (_helper)!
K√ìDTISZT√çT√ÅS (Linter):
Futtasd az adott f√°jlra: ruff check --fix [f√°jl] √©s mypy [f√°jl].
Jav√≠tsd a t√≠pus-hib√°kat (Any helyett konkr√©t t√≠pus, ha lehet).
T√∂r√∂ld a nem haszn√°lt importokat.
DI ELLEN≈êRZ√âS:
Biztos√≠tsd, hogy minden f√ºgg≈ës√©g (logger, config) a konstruktorban j√∂n be (Dependency Injection), nem glob√°lisan.
üß† 4. F√ÅZIS: BOOTSTRAP TISZT√çT√ÅS (core/__init__.py)
A main.py √©s a bootstrap legyen tiszta.
BOOTSTRAP LOGOL√ÅS:
Cser√©ld le a k√©zi logger.info("...") sorokat a @trace dekor√°torra a bootstrap_core f√ºggv√©nyen.
√çgy automatikusan l√°tni fogjuk, mikor indul √©s mikor v√©gez, mennyi id≈ë alatt.
MAIN.PY:
Legyen minimalista. Csak h√≠vja a bootstrap-et √©s kezelje a Ctrl+C-t.
üèÅ 5. F√ÅZIS: Z√ÅR√ÅS
V√âGS≈ê COMMIT:
git add . && git commit -m "refactor(core): harden source code - structlog, tracing, strict types, clean bootstrap"
ARCHITECT! KEZDD AZ 1. F√ÅZISSAL (UTILS & DECORATORS). CSAK AKKOR L√âPJ TOV√ÅBB, HA K√âSZ!"


üìÖ A MENETREND (A k√©r√©sed szerint)
H√°rom k√ºl√∂n√°ll√≥, egym√°sra √©p√ºl≈ë parancsot k√©sz√≠tettem. Ezeket futtasd sorban (ak√°r k√ºl√∂n session√∂kben/√°gakon).
COMMAND A: A Tesztek jav√≠t√°sa (Importok + T√≠pusok).
COMMAND B: Az Automata Dokument√°ci√≥ Gener√°tor (Ez a "Night Run").
COMMAND C: A Phase 2 (JForex) R√©szletes Tervez√©se.
üß™ COMMAND A: TEST SUITE REPAIR (FIX IMPORTS & TYPES)
Ez a parancs v√©gigmegy a teszteken, √©s hozz√°igaz√≠tja ≈ëket a jelenlegi, v√©gleges Core strukt√∫r√°hoz.
M√°sold be Code Mode-ba:
code
Markdown
"Code Agent! (Architect fel√ºgyelettel).
**HELYZET:** A Core k√≥d (`src`) v√©gleges, de a Tesztek (`tests/`) elavultak a refaktor√°l√°s √≥ta. Pylance hib√°k √©s import gondok vannak.
**C√âL:** A megl√©v≈ë tesztek feljav√≠t√°sa, hogy 100%-ban illeszkedjenek az √∫j architekt√∫r√°hoz.

**HAJTSD V√âGRE A K√ñVETKEZ≈êKET (MODULONK√âNT):**

### 1. IMPORT JAV√çT√ÅSOK (Global Fix)
- Menj v√©gig a `tests/core` mapp√°n.
- **Jav√≠tsd az importokat** az √∫j `implementations` / `interfaces` strukt√∫ra szerint.
- *P√©lda:* Ha a teszt a `neural_ai.core.db.session`-t keresi -> √≠rd √°t `neural_ai.core.db.implementations.sqlalchemy_session`-re.

### 2. T√çPUSOSS√ÅG JAV√çT√ÅSA (Pylance Satisfaction)
- Minden teszt met√≥dushoz add hozz√° a visszat√©r√©si t√≠pust: `-> None`.
- Ahol `MagicMock`-ot haszn√°lsz, annot√°ld: `mock_obj: MagicMock`.
- Ha aszinkron a teszt, haszn√°lj `@pytest.mark.asyncio`-t.

### 3. FAGY√ÅS-MENTES√çT√âS (ZMQ Mocking)
- Ellen≈ërizd a `tests/core/events/test_zeromq_bus.py`-t.
- **K√ñTELEZ≈ê:** Biztos√≠tsd, hogy minden tesztben ott legyen a `@patch('zmq.asyncio.Context')`! Val√≥di socket nyit√°sa TILOS.

### 4. VALID√ÅCI√ì
- Futtasd: `pytest`
- **Elv√°r√°s:** 0 Error, 0 Failed.

**KEZDD AZ IMPORTOK ELLEN≈êRZ√âS√âVEL!**"
üìö COMMAND B: AUTO-DOCUMENTATION (THE "NIGHT RUN")
Ezt a parancsot akkor add ki, ha a tesztek m√°r z√∂ldek. Ez nem k√©zzel √≠rja a doksit (ami lass√∫ √©s pontatlan), hanem gener√°l egy scriptet, ami kiszedi a k√≥dodban l√©v≈ë (m√°r megl√©v≈ë, j√≥ min≈ës√©g≈±) docstringeket, √©s Markdown-t csin√°l bel≈ël√ºk.
M√°sold be Code Mode-ba:
code
Markdown
"Code Agent! (Architect fel√ºgyelettel).
**FELADAT:** A teljes rendszer dokument√°ci√≥j√°nak √∫jragener√°l√°sa k√∂zvetlen√ºl a forr√°sk√≥db√≥l (Mirroring).
**M√ìDSZER:** Script-alap√∫ gener√°l√°s a pontoss√°g √©rdek√©ben.

**HAJTSD V√âGRE:**

### 1. GENER√ÅTOR SCRIPT (`scripts/generate_docs.py`)
- √çrj egy Python scriptet, ami:
  1. Bej√°rja a `neural_ai` mapp√°t rekurz√≠van.
  2. Minden `.py` f√°jlt elemez (`ast` vagy `importlib` seg√≠ts√©g√©vel).
  3. Kinyeri az oszt√°lyok √©s f√ºggv√©nyek `docstring`-j√©t.
  4. L√©trehoz egy t√ºk√∂r `.md` f√°jlt a `docs/components/` mapp√°ban.
  5. **Form√°z√°s:** Legyen sz√©p Markdown (C√≠msorok, K√≥dblokkok).

### 2. EXPORT√ÅL√ÅS
- Futtasd le a scriptet: `python scripts/generate_docs.py`
- Ez l√©trehozza a naprak√©sz dokument√°ci√≥t minden f√°jlhoz.

### 3. README FRISS√çT√âS
- Friss√≠tsd a f≈ë `README.md`-t, hogy a linkek az √∫j `docs/components` f√°jlokra mutassanak.

**KEZDD A SCRIPT MEG√çR√ÅS√ÅVAL!**"
üìù COMMAND C: PHASE 2 PLANNING (JFOREX BLUEPRINT)
Ha a Core tiszta (A √©s B parancs k√©sz), akkor ezzel tervezz√ºk meg a k√∂vetkez≈ë l√©p√©st. A megl√©v≈ë 05_collectors_strategy.md-t r√©szletezz√ºk.
M√°sold be Architect Mode-ba:
code
Markdown
"Architect! A Core (Phase 1) lez√°rva.
**C√âL:** A Phase 2 (JForex Collector) r√©szletes megtervez√©se.

**FELADAT: A `docs/planning/phase2_jforex.md` terv elk√©sz√≠t√©se.**

**TARTALOM:**
1.  **Architekt√∫ra:**
    - `JForexDownloader` oszt√°ly diagramja (Interface/Impl).
    - Hogyan csatlakozik az EventBus-hoz? (Milyen eventet k√ºld?)
2.  **Adatstrukt√∫ra:**
    - A `.bi5` f√°jl bin√°ris fel√©p√≠t√©se (struct format stringek).
    - Hogyan konvert√°ljuk `MarketDataEvent`-t√©?
3.  **Hiba kezel√©s:**
    - Mi van, ha a Dukascopy szerver 404-et ad (√ºnnepnap)?
    - Mi van, ha s√©r√ºlt a f√°jl?
4.  **Tesztel√©si Terv:**
    - Hogyan mockoljuk a let√∂lt√©st? (Nem akarunk 100MB-ot let√∂lteni teszt k√∂zben).

**HOZD L√âTRE A TERVET!**"